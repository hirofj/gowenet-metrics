#!/bin/bash

# GOWENET Metrics Collection - Unified Script for Pi1-Pi4
# 全ノード対応・汎用メトリクス収集スクリプト

# ========================================
# ヘルプ表示
# ========================================
show_help() {
    cat << 'HELP'
GOWENET メトリクス収集スクリプト

使い方:
    ./gowenet_metrics.sh [間隔] [継続時間]
    ./gowenet_metrics.sh --help

引数:
    間隔        データ収集間隔（秒） デフォルト: 10秒
    継続時間    データ収集の継続時間（秒） デフォルト: 300秒（5分）

オプション:
    --help, -h  このヘルプを表示

実行例:
    # デフォルト設定（10秒間隔、5分間）
    ./gowenet_metrics.sh

    # カスタム設定（5秒間隔、10分間）
    ./gowenet_metrics.sh 5 600

    # 1秒間隔、1時間（3600秒）
    ./gowenet_metrics.sh 1 3600

    # バックグラウンドで実行
    nohup ./gowenet_metrics.sh 10 3600 > /dev/null 2>&1 &

出力:
    CSVファイル: ~/gowenet-metrics/data/metrics_[ホスト名]_[タイムスタンプ].csv
    ログファイル: ~/gowenet-metrics/logs/metrics_collection.log

収集されるメトリクス:
    - タイムスタンプ
    - ノード名/IP
    - ブロック番号/ハッシュ/タイムスタンプ
    - トランザクション数
    - Gas使用量/制限
    - ピア数
    - バリデータ数
    - 平均ブロック時間

ノード自動検出:
    daikon   (Pi1): 192.168.3.86:9654
    tamago   (Pi2): 192.168.3.75:9650
    tomato   (Pi3): 192.168.3.106:9650
    tamanegi (Pi4): 192.168.3.73:9650

HELP
}

# ヘルプオプションのチェック
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_help
    exit 0
fi

# ========================================
# 設定セクション
# ========================================

# 自動検出：ホスト名からノード番号とIPを取得
HOSTNAME=$(hostname)
CURRENT_IP=$(hostname -I | awk '{print $1}')

# ノード情報マッピング
declare -A NODE_IPS=(
    ["daikon"]="192.168.3.86"    # Pi1
    ["tamago"]="192.168.3.75"    # Pi2
    ["tomato"]="192.168.3.106"   # Pi3
    ["tamanegi"]="192.168.3.73"  # Pi4
)

declare -A NODE_PORTS=(
    ["daikon"]="9654"     # Pi1はNode3のポート
    ["tamago"]="9650"
    ["tomato"]="9650"
    ["tamanegi"]="9650"
)

# 設定の自動取得
NODE_IP="${NODE_IPS[$HOSTNAME]:-$CURRENT_IP}"
NODE_PORT="${NODE_PORTS[$HOSTNAME]:-9650}"

# GOWENET設定
BLOCKCHAIN_ID="2tGwFCjwr3w6fW774ytz982h5Th9eiALrKFanmBKZjxQSqTBxW"
SUBNET_ID="2W9boARgCWL25z6pMFNtkCfNA5v28VGg9PmBgUJfuKndEdhrvw"
RPC_URL="http://${NODE_IP}:${NODE_PORT}/ext/bc/${BLOCKCHAIN_ID}/rpc"
PLATFORM_URL="http://${NODE_IP}:${NODE_PORT}/ext/bc/P"
INFO_URL="http://${NODE_IP}:${NODE_PORT}/ext/info"

# 出力設定
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
OUTPUT_DIR="/home/$USER/gowenet-metrics/data"
LOG_DIR="/home/$USER/gowenet-metrics/logs"
OUTPUT_FILE="${OUTPUT_DIR}/metrics_${HOSTNAME}_${TIMESTAMP}.csv"
LOG_FILE="${LOG_DIR}/metrics_collection.log"

# 収集間隔（秒）
INTERVAL="${1:-10}"
DURATION="${2:-300}"  # デフォルト5分


# ========================================
# 初期化
# ========================================

mkdir -p "$OUTPUT_DIR" "$LOG_DIR"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "=========================================="
log "GOWENET Metrics Collection Started"
log "Node: $HOSTNAME ($NODE_IP:$NODE_PORT)"
log "Output: $OUTPUT_FILE"
log "Interval: ${INTERVAL}s, Duration: ${DURATION}s"
log "=========================================="

# ========================================
# ヘルスチェック
# ========================================

check_node() {
    local response=$(curl -s -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
      -H 'content-type:application/json' "$RPC_URL" 2>/dev/null)
    
    if echo "$response" | grep -q "result"; then
        log "✓ Node is accessible at $RPC_URL"
        return 0
    else
        log "✗ Cannot connect to node at $RPC_URL"
        return 1
    fi
}

if ! check_node; then
    log "ERROR: Node health check failed. Exiting."
    exit 1
fi

# ========================================
# CSVヘッダー作成
# ========================================

cat > "$OUTPUT_FILE" << 'HEADER'
timestamp,node_name,node_ip,block_number,block_hash,block_timestamp,tx_count,gas_used,gas_limit,num_peers,is_bootstrapped,validator_count,avg_block_time
HEADER

log "CSV header created"

# ========================================
# メトリクス収集関数
# ========================================

get_block_number() {
    local result=$(curl -s -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
      -H 'content-type:application/json' "$RPC_URL" 2>/dev/null)
    
    local hex=$(echo "$result" | jq -r '.result // "0x0"' 2>/dev/null)
    if [ -n "$hex" ] && [ "$hex" != "null" ]; then
        printf "%d\n" "$hex" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

get_block_info() {
    local block_num=$1
    local hex_num=$(printf '0x%x' "$block_num" 2>/dev/null)
    curl -s -X POST --data "{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"$hex_num\",false],\"id\":1}" \
      -H 'content-type:application/json' "$RPC_URL" 2>/dev/null | jq -c '.result // {}' 2>/dev/null
}

get_peer_count() {
    local result=$(curl -s -X POST --data '{"jsonrpc":"2.0","method":"info.peers","params":{},"id":1}' \
      -H 'content-type:application/json' "$INFO_URL" 2>/dev/null)
    
    echo "$result" | jq -r '.result.numPeers // 0' 2>/dev/null || echo "0"
}

get_bootstrap_status() {
    local result=$(curl -s -X POST --data '{"jsonrpc":"2.0","method":"info.isBootstrapped","params":{"chain":"C"},"id":1}' \
      -H 'content-type:application/json' "$INFO_URL" 2>/dev/null)
    
    echo "$result" | jq -r '.result.isBootstrapped // false' 2>/dev/null || echo "false"
}

get_validator_count() {
    local result=$(curl -s -X POST --data "{\"jsonrpc\":\"2.0\",\"method\":\"platform.getCurrentValidators\",\"params\":{\"subnetID\":\"$SUBNET_ID\"},\"id\":1}" \
      -H 'content-type:application/json' "$PLATFORM_URL" 2>/dev/null)
    
    echo "$result" | jq -r '.result.validators | length // 0' 2>/dev/null || echo "0"
}

calculate_avg_block_time() {
    local current_block=$1
    local prev_block=$((current_block - 10))
    
    if [ $prev_block -lt 0 ]; then
        echo "0"
        return
    fi
    
    local current_info=$(get_block_info $current_block)
    local prev_info=$(get_block_info $prev_block)
    
    local current_ts=$(echo "$current_info" | jq -r '.timestamp // "0x0"' 2>/dev/null)
    local prev_ts=$(echo "$prev_info" | jq -r '.timestamp // "0x0"' 2>/dev/null)
    
    if [ -n "$current_ts" ] && [ -n "$prev_ts" ] && [ "$current_ts" != "null" ] && [ "$prev_ts" != "null" ]; then
        local current_dec=$(printf "%d\n" "$current_ts" 2>/dev/null || echo "0")
        local prev_dec=$(printf "%d\n" "$prev_ts" 2>/dev/null || echo "0")
        
        if [ $current_dec -gt 0 ] && [ $prev_dec -gt 0 ] && [ $current_dec -gt $prev_dec ]; then
            echo $(( (current_dec - prev_dec) / 10 ))
        else
            echo "0"
        fi
    else
        echo "0"
    fi
}

# ========================================
# メイン収集ループ
# ========================================

START_TIME=$(date +%s)
END_TIME=$((START_TIME + DURATION))
ITERATION=0

log "Starting metrics collection loop..."

while [ $(date +%s) -lt $END_TIME ]; do
    ITERATION=$((ITERATION + 1))
    
    # タイムスタンプ
    TS=$(date '+%Y-%m-%d %H:%M:%S')
    
    # メトリクス収集
    BLOCK_NUM=$(get_block_number)
    
    if [ "$BLOCK_NUM" -gt 0 ]; then
        BLOCK_INFO=$(get_block_info $BLOCK_NUM)
        BLOCK_HASH=$(echo "$BLOCK_INFO" | jq -r '.hash // "N/A"' 2>/dev/null)
        BLOCK_TS=$(echo "$BLOCK_INFO" | jq -r '.timestamp // "0x0"' 2>/dev/null)
        BLOCK_TS_DEC=$(printf "%d\n" "$BLOCK_TS" 2>/dev/null || echo "0")
        TX_COUNT=$(echo "$BLOCK_INFO" | jq -r '.transactions | length // 0' 2>/dev/null)
        GAS_USED=$(echo "$BLOCK_INFO" | jq -r '.gasUsed // "0x0"' 2>/dev/null)
        GAS_USED_DEC=$(printf "%d\n" "$GAS_USED" 2>/dev/null || echo "0")
        GAS_LIMIT=$(echo "$BLOCK_INFO" | jq -r '.gasLimit // "0x0"' 2>/dev/null)
        GAS_LIMIT_DEC=$(printf "%d\n" "$GAS_LIMIT" 2>/dev/null || echo "0")
    else
        BLOCK_HASH="N/A"
        BLOCK_TS_DEC="0"
        TX_COUNT="0"
        GAS_USED_DEC="0"
        GAS_LIMIT_DEC="0"
    fi
    
    NUM_PEERS=$(get_peer_count)
    IS_BOOTSTRAPPED=$(get_bootstrap_status)
    VALIDATOR_COUNT=$(get_validator_count)
    AVG_BLOCK_TIME=$(calculate_avg_block_time $BLOCK_NUM)
    
    # CSV出力
    echo "${TS},${HOSTNAME},${NODE_IP},${BLOCK_NUM},${BLOCK_HASH},${BLOCK_TS_DEC},${TX_COUNT},${GAS_USED_DEC},${GAS_LIMIT_DEC},${NUM_PEERS},${IS_BOOTSTRAPPED},${VALIDATOR_COUNT},${AVG_BLOCK_TIME}" >> "$OUTPUT_FILE"
    
    # ログ出力（10イテレーションごと）
    if [ $((ITERATION % 10)) -eq 0 ]; then
        log "Iteration $ITERATION: Block #$BLOCK_NUM, Peers: $NUM_PEERS, Validators: $VALIDATOR_COUNT"
    fi
    
    # 待機
    sleep $INTERVAL
done

# ========================================
# 完了処理
# ========================================

TOTAL_RECORDS=$(wc -l < "$OUTPUT_FILE")
log "=========================================="
log "Metrics collection completed"
log "Total records: $((TOTAL_RECORDS - 1))"
log "Output file: $OUTPUT_FILE"
log "=========================================="

# サマリー表示
log "=== Collection Summary ==="
log "Node: $HOSTNAME ($NODE_IP)"
log "Duration: ${DURATION}s"
log "Interval: ${INTERVAL}s"
log "Iterations: $ITERATION"
log "Final Block: $(tail -1 "$OUTPUT_FILE" | cut -d',' -f4)"
log "=========================="

exit 0
